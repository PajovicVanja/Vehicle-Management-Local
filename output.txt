Output generated at: 2025-10-04T16:26:23.456Z
Project root: C:\aaFERI\PREDMETI\3. Semestar\VUI\App\RIRSsolo

====================
DUMP FROM DIRECTORIES
====================

=== FILE START ===
Path: api\auth\[...path].js
--- CONTENT START ---
// api/auth/[...path].js
const formidable = require('formidable');
const cloudinary = require('../_lib/cloudinary');
const { db } = require('../_lib/firebaseAdmin');
const { verifyAuth } = require('../_lib/verifyAuth');
const { setCors, handlePreflight } = require('../_lib/cors');

module.exports = async (req, res) => {
  if (handlePreflight(req, res)) return; // OPTIONS
setCors(req, res);  
const seg = req.query.path;
  const parts = Array.isArray(seg) ? seg : (seg ? [seg] : []);

  const user = await verifyAuth(req, res);
  if (!user) return;

  try {
    // GET /api/auth/profile
    if (parts.length === 1 && parts[0] === 'profile' && req.method === 'GET') {
      const userDoc = await db.collection('users').doc(user.uid).get();
      if (!userDoc.exists) return res.status(404).json({ message: 'User document not found' });

      const data = userDoc.data();
      return res.status(200).json({
        email: data.email,
        role: data.role || 'Driver',
        licenseImageUrl: data.licenseImageUrl || null
      });
    }

    // POST /api/auth/upload-license
    if (parts.length === 1 && parts[0] === 'upload-license' && req.method === 'POST') {
      const form = formidable({ multiples: false, keepExtensions: true });
      const { files } = await new Promise((resolve, reject) => {
        form.parse(req, (err, fields, files) => (err ? reject(err) : resolve({ fields, files })));
      });

      const file = files.licenseImage;
      if (!file) return res.status(400).json({ message: 'No file uploaded' });

      const upload = await cloudinary.uploader.upload(file.filepath, {
        folder: `licenses/${user.uid}`
      });

      const imageUrl = upload.secure_url;

      const ref = db.collection('users').doc(user.uid);
      const snap = await ref.get();
      if (!snap.exists) return res.status(404).json({ message: 'User document not found' });

      await ref.update({ licenseImageUrl: imageUrl });
      return res.status(200).json({ message: 'License image uploaded successfully', imageUrl });
    }

    return res.status(404).json({ message: 'Not found' });
  } catch (e) {
    console.error('auth catch-all error:', e);
    return res.status(500).json({ message: 'Server error', error: e.message });
  }
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\health.js
--- CONTENT START ---
// api/health.js
module.exports = (req, res) => {
  res.status(200).json({ status: 'ok', message: 'API is running', timestamp: new Date().toISOString() });
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\reservation\[...path].js
--- CONTENT START ---
// api/reservation/[...path].js
const { db } = require('../_lib/firebaseAdmin');
const { verifyAuth } = require('../_lib/verifyAuth');
const { setCors, handlePreflight } = require('../_lib/cors');

module.exports = async (req, res) => {
  if (handlePreflight(req, res)) return; // OPTIONS
  setCors(req, res);
  const seg = req.query.path;
  const parts = Array.isArray(seg) ? seg : (seg ? [seg] : []);

  const user = await verifyAuth(req, res);
  if (!user) return;

  try {
    // GET /api/reservation/reservation
    if (parts.length === 1 && parts[0] === 'reservation' && req.method === 'GET') {
      const snap = await db.collection('reservation').get();
      const list = snap.docs.map(d => d.data());
      return res.status(200).json(list);
    }

    // GET or DELETE /api/reservation/reservation/:resId
    if (parts.length === 2 && parts[0] === 'reservation') {
      const resId = parts[1];

      if (req.method === 'GET') {
        const ref = db.collection('reservation').doc(resId);
        const doc = await ref.get();
        if (!doc.exists) return res.status(404).json({ message: 'Reservation not found' });
        return res.status(200).json({ id: doc.id, ...doc.data() });
      }

      if (req.method === 'DELETE') {
        const snap = await db.collection('reservation').where('reservationId', '==', resId).get();
        if (snap.empty) return res.status(404).json({ message: 'No reservation found with the specified ID' });
        const batch = db.batch();
        snap.forEach(d => batch.delete(d.ref));
        await batch.commit();
        return res.status(200).json({ message: `Reservation with id '${resId}' successfully deleted` });
      }

      return res.status(405).json({ message: 'Method not allowed' });
    }

    return res.status(404).json({ message: 'Not found' });
  } catch (e) {
    console.error('reservation catch-all error:', e);
    return res.status(500).json({ message: 'Server error', error: e.message });
  }
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\vehicle\[...path].js
--- CONTENT START ---
// api/vehicle/[...path].js
const { db } = require('../_lib/firebaseAdmin');
const { verifyAuth } = require('../_lib/verifyAuth');
const { setCors, handlePreflight } = require('../_lib/cors');

module.exports = async (req, res) => {
  if (handlePreflight(req, res)) return; // OPTIONS
  setCors(req, res);

  const seg = req.query.path;
  const parts = Array.isArray(seg) ? seg : (seg ? [seg] : []);

  const user = await verifyAuth(req, res);
  if (!user) return;

  try {
    // GET /api/vehicle/vehicles
    if (parts.length === 1 && parts[0] === 'vehicles' && req.method === 'GET') {
      const snapshot = await db.collection('vehicles').get();
      const list = snapshot.docs.map(d => d.data());
      return res.status(200).json(list);
    }

    // GET or DELETE /api/vehicle/vehicles/:vehicleId
    if (parts.length === 2 && parts[0] === 'vehicles') {
      const vehicleId = parts[1];

      if (req.method === 'GET') {
        const ref = db.collection('vehicles').doc(vehicleId);
        const doc = await ref.get();
        if (!doc.exists) return res.status(404).json({ message: 'Vehicle not found' });
        return res.status(200).json({ id: doc.id, ...doc.data() });
      }

      if (req.method === 'DELETE') {
        if (user.role !== 'Admin') {
          return res.status(403).json({ message: 'Only admins can delete vehicles.' });
        }
        const q = await db.collection('vehicles').where('vehicleId', '==', vehicleId).get();
        if (q.empty) return res.status(404).json({ message: 'No vehicle found with the specified ID' });
        const batch = db.batch();
        q.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        return res.status(200).json({ message: `Vehicle(s) with id '${vehicleId}' successfully deleted` });
      }

      return res.status(405).json({ message: 'Method not allowed' });
    }
    if (parts.length === 1 && parts[0] === 'vehicles' && req.method === 'POST') {
  if (user.role !== 'Admin') {
    return res.status(403).json({ message: 'Only admins can add vehicles.' });
  }
  const { vehicleName, engine, hp, color, year } = req.body || {};
  if (!vehicleName || !engine || !hp || !color || !year) {
    return res.status(400).json({ message: 'Missing required fields.' });
  }
  const ref = db.collection('vehicles').doc();
  const vehicleId = ref.id;
  const newVehicle = { vehicleId, vehicleName, engine, hp, color, year, status: 'available' };
  await ref.set(newVehicle);
  return res.status(201).json({ success: true, data: newVehicle });
}
    // PATCH actions on /api/vehicle/vehicles/:vehicleId/(reserve|unreserve|repair)
    if (parts.length === 3 && parts[0] === 'vehicles') {
      const vehicleId = parts[1];
      const action = parts[2];

      // PATCH /repair
      if (action === 'repair' && req.method === 'PATCH') {
        const ref = db.collection('vehicles').doc(vehicleId);
        const snap = await ref.get();
        if (!snap.exists) return res.status(404).json({ message: 'Vehicle not found' });

        const data = snap.data();
        if (data.status !== 'repair') {
          return res.status(400).json({ message: 'Cannot change status, vehicle is not in repair.' });
        }

        await ref.update({ status: 'available' });

        // remove malfunctions for this vehicle
        const m = await db.collection('malfunctions').where('vehicleId', '==', vehicleId).get();
        if (!m.empty) {
          const batch = db.batch();
          m.forEach(doc => batch.delete(doc.ref));
          await batch.commit();
        }

        return res.status(200).json({ message: `Vehicle ${vehicleId} status updated to "available" and malfunction(s) deleted.` });
      }

      // PATCH /unreserve
      if (action === 'unreserve' && req.method === 'PATCH') {
        const ref = db.collection('vehicles').doc(vehicleId);
        const snap = await ref.get();
        if (!snap.exists) return res.status(404).json({ message: 'Vehicle not found' });

        const data = snap.data();
        if (data.status === 'available' || data.status === 'repair') {
          return res.status(400).json({ message: 'Cannot change status, vehicle is not reserved.' });
        }

        await ref.update({ status: 'available' });
        return res.status(200).json({ message: `Vehicle ${vehicleId} status updated to "available".` });
      }

      // PATCH /reserve
      if (action === 'reserve' && req.method === 'PATCH') {
        const { startDate, endDate } = req.body || {};
        if (!startDate || !endDate) {
          return res.status(400).json({ success: false, message: 'Start date and end date are required.' });
        }

        const vRef = db.collection('vehicles').doc(vehicleId);
        const vDoc = await vRef.get();
        if (!vDoc.exists) return res.status(404).json({ success: false, message: 'Vehicle not found.' });

        const v = vDoc.data();
        if (v.status !== 'available') {
          return res.status(400).json({ success: false, message: 'Vehicle is not available for reservation.' });
        }

        const resRef = db.collection('reservation').doc();
        const reservationId = resRef.id;

        await resRef.set({
          reservationId,
          vehicleId,
          userId: user.uid,
          startDate,
          endDate,
          status: 'Active',
          createdAt: new Date()
        });

        await vRef.update({ status: reservationId });

        return res.status(201).json({ success: true, message: 'Reservation created successfully.' });
      }

      // POST /report-issue
      if (action === 'report-issue' && req.method === 'POST') {
        const { description } = req.body || {};
        if (!description) return res.status(400).json({ message: 'Description is required.' });

        const vRef = db.collection('vehicles').doc(vehicleId);
        const vDoc = await vRef.get();
        if (!vDoc.exists) return res.status(404).json({ message: 'Vehicle not found.' });

        // log malfunction
        await db.collection('malfunctions').doc().set({
          vehicleId,
          userId: user.uid,
          description,
          status: 'Pending',
          createdAt: new Date()
        });

        // set vehicle to repair
        await vRef.update({ status: 'repair' });

        // delete active reservations for this vehicle
        const rQ = await db.collection('reservation')
          .where('vehicleId', '==', vehicleId)
          .where('status', '==', 'Active')
          .get();

        if (!rQ.empty) {
          const batch = db.batch();
          rQ.forEach(doc => batch.delete(doc.ref));
          await batch.commit();
        }

        return res.status(201).json({ message: `Issue reported for vehicle ${vehicleId}, status updated to "repair", and associated reservation deleted.` });
      }

      return res.status(405).json({ message: 'Method not allowed' });
    }

    // GET /api/vehicle/malfunctions
    if (parts.length === 1 && parts[0] === 'malfunctions' && req.method === 'GET') {
      const snap = await db.collection('malfunctions').get();
      const list = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      return res.status(200).json(list);
    }

    // GET /api/vehicle/admin-reservations (Admin only)
    if (parts.length === 1 && parts[0] === 'admin-reservations' && req.method === 'GET') {
      if (user.role !== 'Admin') {
        return res.status(403).json({ message: 'Unauthorized access. Only admins can view reservations.' });
      }
      const snap = await db.collection('reservation').get();
      const out = [];
      for (const doc of snap.docs) {
        const r = doc.data();
        let vehicle = null;
        if (r.vehicleId) {
          const v = await db.collection('vehicles').doc(r.vehicleId).get();
          vehicle = v.exists ? v.data() : null;
        }
        let userData = null;
        if (r.userId) {
          const u = await db.collection('users').doc(r.userId).get();
          userData = u.exists ? u.data() : null;
        }
        out.push({
          reservationId: r.reservationId,
          startDate: r.startDate,
          endDate: r.endDate,
          status: r.status,
          user: userData ? { email: userData.email || 'N/A', licenseImageUrl: userData.licenseImageUrl || null } : { email: 'N/A', licenseImageUrl: null },
          vehicle: vehicle ? { vehicleName: vehicle.vehicleName || 'N/A', color: vehicle.color || 'N/A', engine: vehicle.engine || 'N/A' } : { vehicleName: 'N/A', color: 'N/A', engine: 'N/A' }
        });
      }
      return res.status(200).json({ success: true, data: out });
    }

    return res.status(404).json({ message: 'Not found' });
  } catch (e) {
    console.error('vehicle catch-all error:', e);
    return res.status(500).json({ message: 'Server error', error: e.message });
  }
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\_lib\cloudinary.js
--- CONTENT START ---
// api/_lib/cloudinary.js
const cloudinary = require('cloudinary').v2;

const { CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET } = process.env;

if (!CLOUDINARY_CLOUD_NAME || !CLOUDINARY_API_KEY || !CLOUDINARY_API_SECRET) {
  console.warn('Cloudinary environment variables are missing; image upload routes will fail.');
}

cloudinary.config({
  cloud_name: CLOUDINARY_CLOUD_NAME,
  api_key: CLOUDINARY_API_KEY,
  api_secret: CLOUDINARY_API_SECRET
});

module.exports = cloudinary;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\_lib\cors.js
--- CONTENT START ---
// api/_lib/cors.js
const STATIC_ALLOW = new Set([
  'https://company-vehicle-management.web.app',
  'https://company-vehicle-management.firebaseapp.com',
  'http://localhost:3000',
  // add your stable Vercel domain(s):
  'https://vehicle-management-frontend-alpha.vercel.app'
]);

function isAllowed(origin) {
  if (!origin) return false;
  if (STATIC_ALLOW.has(origin)) return true;

  // allow your Vercel/Firebase preview hosts too
  try {
    const { hostname } = new URL(origin);
    if (hostname.endsWith('.vercel.app')) return true;
    if (hostname.endsWith('.web.app')) return true;
    if (hostname.endsWith('.firebaseapp.com')) return true;
  } catch (_) {}
  return false;
}

function setCors(req, res) {
  const origin = req.headers.origin;
  if (isAllowed(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  } else {
    // since you use Bearer tokens (no cookies), "*" is fine
    res.setHeader('Access-Control-Allow-Origin', '*');
  }
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PATCH,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Authorization, Content-Type, X-Requested-With');
  res.setHeader('Access-Control-Max-Age', '86400');
}

function handlePreflight(req, res) {
  if (req.method === 'OPTIONS') {
    setCors(req, res);
    res.status(204).end();
    return true;
  }
  return false;
}

module.exports = { setCors, handlePreflight };
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\_lib\firebaseAdmin.js
--- CONTENT START ---
// api/_lib/firebaseAdmin.js
const admin = require('firebase-admin');

if (!admin.apps.length) {
  // All creds must be set as Vercel environment variables
  const {
    FIREBASE_PROJECT_ID,
    FIREBASE_PRIVATE_KEY_ID,
    FIREBASE_PRIVATE_KEY,
    FIREBASE_CLIENT_EMAIL,
    FIREBASE_CLIENT_ID,
    FIREBASE_AUTH_URI,
    FIREBASE_TOKEN_URI,
    FIREBASE_AUTH_PROVIDER_CERT_URL,
    FIREBASE_CLIENT_CERT_URL
  } = process.env;

  if (!FIREBASE_PROJECT_ID || !FIREBASE_PRIVATE_KEY || !FIREBASE_CLIENT_EMAIL) {
    throw new Error('Firebase Admin environment variables are missing');
  }

  admin.initializeApp({
    credential: admin.credential.cert({
      project_id: FIREBASE_PROJECT_ID,
      private_key_id: FIREBASE_PRIVATE_KEY_ID,
      private_key: FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
      client_email: FIREBASE_CLIENT_EMAIL,
      client_id: FIREBASE_CLIENT_ID,
      auth_uri: FIREBASE_AUTH_URI,
      token_uri: FIREBASE_TOKEN_URI,
      auth_provider_x509_cert_url: FIREBASE_AUTH_PROVIDER_CERT_URL,
      client_x509_cert_url: FIREBASE_CLIENT_CERT_URL
    })
  });
}

const db = admin.firestore();

module.exports = { admin, db };
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\_lib\verifyAuth.js
--- CONTENT START ---
// api/_lib/verifyAuth.js
const { admin, db } = require('./firebaseAdmin');

async function verifyAuth(req, res) {
  try {
    const authHeader = req.headers.authorization || '';
    const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;
    if (!token) {
      res.status(401).json({ message: 'Authorization token missing' });
      return null;
    }
    const decoded = await admin.auth().verifyIdToken(token);
    const uid = decoded.uid;

    // Fetch Firestore role (default Driver)
    let role = 'Driver';
    const userDoc = await db.collection('users').doc(uid).get();
    if (userDoc.exists) role = userDoc.data().role || 'Driver';

    return { uid, role, decoded };
  } catch (e) {
    console.error('Auth verify error:', e);
    res.status(403).json({ message: 'Unauthorized access' });
    return null;
  }
}

module.exports = { verifyAuth };
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\__tests__\auth.test.js
--- CONTENT START ---
const path = require('path');
const httpMocks = require('node-mocks-http');
const { createMockDb } = require('./helpers/mockDb');

const authHandlerPath = path.resolve(__dirname, '..', 'auth', '[...path].js');
const verifyAuthPath = path.resolve(__dirname, '..', '_lib', 'verifyAuth.js');
const firebaseAdminPath = path.resolve(__dirname, '..', '_lib', 'firebaseAdmin.js');

describe('Auth API', () => {
  let handler;
  let mockDb;

  beforeEach(() => {
    jest.resetModules();
    mockDb = createMockDb({
      users: {
        // seed user doc without explicit role (defaults to Driver)
        u1: { email: 'admin@example.com' }
      }
    });

    jest.doMock(verifyAuthPath, () => ({
      verifyAuth: jest.fn().mockResolvedValue({ uid: 'u1', role: 'Admin' })
    }));
    jest.doMock(firebaseAdminPath, () => ({ db: mockDb }));

    handler = require(authHandlerPath);
  });

  test('GET /api/auth/profile returns email and default role', async () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/api/auth/profile',
      query: { path: ['profile'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const body = res._getJSONData();
    expect(body.email).toBe('admin@example.com');
    expect(body.role).toBe('Driver'); // default when not set
  });

  test('GET /api/auth/profile 404 when user doc missing', async () => {
    // reset with no user doc
    jest.resetModules();
    mockDb = createMockDb({ users: {} });
    jest.doMock(verifyAuthPath, () => ({
      verifyAuth: jest.fn().mockResolvedValue({ uid: 'missing', role: 'Admin' })
    }));
    jest.doMock(firebaseAdminPath, () => ({ db: mockDb }));
    handler = require(authHandlerPath);

    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/api/auth/profile',
      query: { path: ['profile'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(404);
  });
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\__tests__\helpers\mockDb.js
--- CONTENT START ---
// api/__tests__/helpers/mockDb.js

// Very small Firestore-in-memory mock that supports the subset of features
// your handlers/tests use: collection().doc().{get,set,update,delete},
// collection().get(), collection().where(...).where(...).get(),
// and db.batch().delete(ref).commit().
//
// Key detail: every doc "ref" includes a pointer to its parent collection
// via `ref._collection`, so batch.delete(ref) can mutate the correct store.

let autoId = 0;
const genId = () => `auto_${++autoId}`;

function createCollection(initial = {}) {
  const store = new Map(Object.entries(initial)); // id -> data

  // Query wrapper that shares the same underlying store and applies filters.
  function makeQuery(col, filters = []) {
    return {
      _name: col._name,
      _filters: filters,
      _getData: () => store,
      where(field, op, value) {
        if (op !== '==') throw new Error('mockDb only supports == in where()');
        return makeQuery(col, [...this._filters, { field, op, value }]);
      },
      async get() {
        const filtered = Array.from(store.entries()).filter(([, data]) =>
          this._filters.every(f => (f.op === '==' ? data[f.field] === f.value : false))
        );
        const docs = filtered.map(([id, data]) => ({
          id,
          data: () => data,
          // include the originating collection so batch.delete can work
          ref: { id, _collection: col }
        }));
        return { docs, empty: docs.length === 0, forEach: cb => docs.forEach(cb) };
      }
    };
  }

  const col = {
    _name: null,
    _filters: [],
    // expose underlying map so batch.delete can mutate it
    _getData: () => store,

    doc(id) {
      const _id = id || genId();
      return {
        id: _id,
        async get() {
          const exists = store.has(_id);
          return { id: _id, exists, data: () => (exists ? store.get(_id) : undefined) };
        },
        async set(data) {
          store.set(_id, { ...(data || {}) });
        },
        async update(patch) {
          if (!store.has(_id)) throw new Error('not-found');
          store.set(_id, { ...store.get(_id), ...(patch || {}) });
        },
        async delete() {
          store.delete(_id);
        },
        get ref() {
          // IMPORTANT: keep a pointer back to the collection
          return { id: _id, _collection: col };
        }
      };
    },

    where(field, op, value) {
      if (op !== '==') throw new Error('mockDb only supports == in where()');
      return makeQuery(col, [{ field, op, value }]);
    },

    async get() {
      const docs = Array.from(store.entries()).map(([id, data]) => ({
        id,
        data: () => data,
        ref: { id, _collection: col }
      }));
      return { docs, empty: docs.length === 0, forEach: cb => docs.forEach(cb) };
    }
  };

  return col;
}

function createMockDb(seed = {}) {
  const collections = {};
  const ensure = (name) => {
    if (!collections[name]) {
      collections[name] = createCollection(seed[name] || {});
      collections[name]._name = name;
    }
    return collections[name];
  };

  return {
    collection(name) {
      return ensure(name);
    },

    batch() {
      const ops = [];
      return {
        delete(ref) {
          ops.push({ type: 'delete', ref });
        },
        async commit() {
          for (const op of ops) {
            if (op.type === 'delete') {
              const col = op.ref && op.ref._collection;
              if (!col) continue; // nothing to do if no collection pointer
              const map = col._getData ? col._getData() : null;
              if (map) map.delete(op.ref.id);
            }
          }
        }
      };
    }
  };
}

module.exports = { createMockDb };
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\__tests__\reservation.test.js
--- CONTENT START ---
const path = require('path');
const httpMocks = require('node-mocks-http');
const { createMockDb } = require('./helpers/mockDb');

const reservationHandlerPath = path.resolve(__dirname, '..', 'reservation', '[...path].js');
const verifyAuthPath = path.resolve(__dirname, '..', '_lib', 'verifyAuth.js');
const firebaseAdminPath = path.resolve(__dirname, '..', '_lib', 'firebaseAdmin.js');

describe('Reservation API', () => {
  let handler;
  let mockDb;

  beforeEach(() => {
    jest.resetModules();
    mockDb = createMockDb({
      reservation: {
        r1: { reservationId: 'r1', vehicleId: 'veh1', userId: 'u1', status: 'Active' },
        r2: { reservationId: 'r2', vehicleId: 'veh2', userId: 'u2', status: 'Cancelled' }
      }
    });

    jest.doMock(verifyAuthPath, () => ({
      verifyAuth: jest.fn().mockResolvedValue({ uid: 'u1', role: 'Admin' })
    }));
    jest.doMock(firebaseAdminPath, () => ({ db: mockDb }));

    handler = require(reservationHandlerPath);
  });

  test('GET /api/reservation/reservation returns all reservations', async () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/api/reservation/reservation',
      query: { path: ['reservation'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);
    expect(res._getStatusCode()).toBe(200);
    const body = res._getJSONData();
    expect(Array.isArray(body)).toBe(true);
    expect(body.length).toBe(2);
  });

  test('DELETE /api/reservation/reservation/:id deletes by reservationId', async () => {
    const req = httpMocks.createRequest({
      method: 'DELETE',
      url: '/api/reservation/reservation/r1',
      query: { path: ['reservation', 'r1'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);
    expect(res._getStatusCode()).toBe(200);

    const remaining = (await mockDb.collection('reservation').get()).docs.map(d => d.data());
    expect(remaining.length).toBe(1);
    expect(remaining[0].reservationId).toBe('r2');
  });
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: api\__tests__\vehicle.test.js
--- CONTENT START ---
const path = require('path');
const httpMocks = require('node-mocks-http');
const { createMockDb } = require('./helpers/mockDb');

const vehicleHandlerPath = path.resolve(__dirname, '..', 'vehicle', '[...path].js');
const verifyAuthPath = path.resolve(__dirname, '..', '_lib', 'verifyAuth.js');
const firebaseAdminPath = path.resolve(__dirname, '..', '_lib', 'firebaseAdmin.js');

describe('Vehicle API', () => {
  let handler;
  let mockDb;

  const seed = () => ({
    users: {
      u1: { email: 'admin@example.com', role: 'Admin' }
    },
    vehicles: {
      veh1: { vehicleId: 'veh1', vehicleName: 'Car A', engine: 'V6', hp: '200', color: 'Red', year: '2020', status: 'available' },
      veh2: { vehicleId: 'veh2', vehicleName: 'Car B', engine: 'I4', hp: '120', color: 'Blue', year: '2019', status: 'repair' }
    },
    reservation: {},
    malfunctions: {}
  });

  beforeEach(() => {
    jest.resetModules();
    mockDb = createMockDb(seed());

    jest.doMock(verifyAuthPath, () => ({
      verifyAuth: jest.fn().mockResolvedValue({ uid: 'u1', role: 'Admin' })
    }));
    jest.doMock(firebaseAdminPath, () => ({ db: mockDb }));

    handler = require(vehicleHandlerPath);
  });

  test('GET /api/vehicle/vehicles returns list', async () => {
    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/api/vehicle/vehicles',
      query: { path: ['vehicles'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const body = res._getJSONData();
    expect(Array.isArray(body)).toBe(true);
    expect(body.length).toBe(2);
  });

  test('PATCH /vehicles/:id/reserve succeeds when available', async () => {
    const req = httpMocks.createRequest({
      method: 'PATCH',
      url: '/api/vehicle/vehicles/veh1/reserve',
      query: { path: ['vehicles', 'veh1', 'reserve'] },
      headers: { authorization: 'Bearer x' },
      body: { startDate: '2025-01-01', endDate: '2025-01-03' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(201);
    // Verify vehicle status changed from "available" to reservationId (some auto id)
    const vehSnap = await mockDb.collection('vehicles').doc('veh1').get();
    const veh = vehSnap.data();
    expect(veh.status).toMatch(/^auto_/);

    // Verify reservation created
    const reservations = (await mockDb.collection('reservation').get()).docs.map(d => d.data());
    expect(reservations.length).toBe(1);
    expect(reservations[0].vehicleId).toBe('veh1');
  });

  test('PATCH /vehicles/:id/reserve fails when not available', async () => {
    const req = httpMocks.createRequest({
      method: 'PATCH',
      url: '/api/vehicle/vehicles/veh2/reserve',
      query: { path: ['vehicles', 'veh2', 'reserve'] },
      headers: { authorization: 'Bearer x' },
      body: { startDate: '2025-01-01', endDate: '2025-01-03' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(400);
  });

  test('PATCH /vehicles/:id/unreserve sets status to available', async () => {
    // First, simulate reserved status
    await mockDb.collection('vehicles').doc('veh1').update({ status: 'auto_999' });

    const req = httpMocks.createRequest({
      method: 'PATCH',
      url: '/api/vehicle/vehicles/veh1/unreserve',
      query: { path: ['vehicles', 'veh1', 'unreserve'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const veh = (await mockDb.collection('vehicles').doc('veh1').get()).data();
    expect(veh.status).toBe('available');
  });

  test('POST /vehicles/:id/report-issue sets vehicle to repair, adds malfunction, deletes active reservations', async () => {
    // Seed an active reservation for veh1
    const rRef = mockDb.collection('reservation').doc('r1');
    await rRef.set({
      reservationId: 'r1',
      vehicleId: 'veh1',
      userId: 'u1',
      status: 'Active',
      startDate: '2025-01-01',
      endDate: '2025-01-02'
    });

    const req = httpMocks.createRequest({
      method: 'POST',
      url: '/api/vehicle/vehicles/veh1/report-issue',
      query: { path: ['vehicles', 'veh1', 'report-issue'] },
      headers: { authorization: 'Bearer x' },
      body: { description: 'brake noise' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);
    expect(res._getStatusCode()).toBe(201);

    const veh = (await mockDb.collection('vehicles').doc('veh1').get()).data();
    expect(veh.status).toBe('repair');

    const mal = (await mockDb.collection('malfunctions').get()).docs.map(d => d.data());
    expect(mal.length).toBe(1);
    expect(mal[0].description).toBe('brake noise');

    const reservations = (await mockDb.collection('reservation').get()).docs.map(d => d.data());
    expect(reservations.length).toBe(0); // active reservation deleted
  });

  test('GET /api/vehicle/admin-reservations aggregates vehicle and user info', async () => {
    // Seed a reservation and related docs
    const resRef = mockDb.collection('reservation').doc('r2');
    await resRef.set({
      reservationId: 'r2',
      vehicleId: 'veh1',
      userId: 'u1',
      startDate: '2025-02-01',
      endDate: '2025-02-03',
      status: 'Active'
    });

    const req = httpMocks.createRequest({
      method: 'GET',
      url: '/api/vehicle/admin-reservations',
      query: { path: ['admin-reservations'] },
      headers: { authorization: 'Bearer x' }
    });
    const res = httpMocks.createResponse();

    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const body = res._getJSONData();
    expect(body.success).toBe(true);
    expect(Array.isArray(body.data)).toBe(true);
    expect(body.data[0].vehicle.vehicleName).toBe('Car A');
    expect(body.data[0].user.email).toBe('admin@example.com');
  });
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\package.json
--- CONTENT START ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "firebase": "^11.0.1",
    "react": "^18.3.1",
    "react-calendar": "^5.1.0",
    "react-date-picker": "^11.0.0",
    "react-dom": "^18.3.1",
    "react-scripts": "^5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --watchAll=false",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.0.1",
    "@testing-library/user-event": "^14.5.2"
  }
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\public\index.html
--- CONTENT START ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\public\manifest.json
--- CONTENT START ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\public\robots.txt
--- CONTENT START ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\App.css
--- CONTENT START ---
.menu-group{
  display: flex;
  flex-direction: column;
  justify-content: center; /* Centers buttons horizontally */
  align-items: center; /* Centers buttons vertically */
}

.button-group {
    display: flex;
    justify-content: center; /* Centers buttons horizontally */
    align-items: center; /* Centers buttons vertically */
    gap: 10px;
  }
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\App.js
--- CONTENT START ---
import React, { useState, useEffect } from 'react';
import './App.css';
import Register from './components/Register';
import Login from './components/Login';
import Profile from './components/Profile';
import ReserveVehicle from './components/ReserveVehicle';
import AddVehicle from './components/AddVehicle';
import UploadLicense from './components/UploadLicense';
import CurrentReservationsAdmin from './components/CurrentReservationsAdmin';
import ViewReservation from './components/ViewReservation';
import { getUserData } from './services/authService';
import { getAuth } from 'firebase/auth'; // Import Firebase Authentication

import { getReservationData } from './services/reservationService';

function App() {
  const [token, setToken] = useState(null); // Auth token
  const [role, setRole] = useState(''); // User role (Driver, Admin, Manager)
  const [licenseUploaded, setLicenseUploaded] = useState(false); // Driver's license status

  // UI Navigation States
  const [showRegister, setShowRegister] = useState(false);
  const [showProfile, setShowProfile] = useState(false);
  const [showReserve, setShowReserve] = useState(false); // Used for viewing vehicles
  const [showAddVehicle, setShowAddVehicle] = useState(false);
  const [showAllCarReservations, setShowAllCarReservations] = useState(false);

  //Reservation form
  const [uid, setUid] = useState(null);
  const [reservations, setReservations] = useState([]); 
  const [userReservation, setUserReservation] = useState(null);

  // Fetch role and license status after login
  useEffect(() => {
    // Fetch role and license status after login
    const fetchRole = async () => {
      if (token) {
        const userData = await getUserData(token);
        if (userData.success) {
          setRole(userData.data.role || 'Driver');
          setLicenseUploaded(!!userData.data.licenseImageUrl);

          const fetchAllReservations = async () => {
            try {
              const vehicleSnapshot = await getReservationData(token);
              if (vehicleSnapshot.success) {
                setReservations(vehicleSnapshot.data);
              }
            } catch (error) {
              console.log(error);
            }
          };

          fetchAllReservations();
          // Get the authenticated user's UIDd
          const auth = getAuth();
          const user = auth.currentUser;
          user ? setUid(user.uid) : setUid(null);
        }
      }
    };
    fetchRole();
  }, [token]);

  useEffect(() => {
    // Fetch user reservation only after `reservations` and `uid` have been set
    if (reservations.length > 0 && uid) {
      const userRes = reservations.find(res => res.userId === uid);
      setUserReservation(userRes);
    }
  }, [reservations, uid]);
  
  return (
    <div>
      <h1>Vehicle Management System</h1>
      {!token ? (
        <>
          {/* Register or Login UI */}
          {showRegister ? (
            <Register setToken={setToken} />
          ) : (
            <Login setToken={setToken} />
          )}
          <button
            className="goto-register-button"
            onClick={() => setShowRegister(!showRegister)}
          >
            {showRegister ? 'Switch to Login' : 'Switch to Register'}
          </button>
        </>
      ) : showAddVehicle ? (
        <AddVehicle token={token} setShowAddVehicle={setShowAddVehicle} />
      ) : showReserve ? (
        <ReserveVehicle
          token={token}
          setShowReserve={setShowReserve}
          setShowAddVehicle={setShowAddVehicle}
          setShowAllCarReservations={setShowAllCarReservations}
          canReserve={role === 'Driver'} 
          userReservationReset={setUserReservation}
        />
      ) : showProfile ? (
        <Profile token={token} setShowProfile={setShowProfile} />
      ) : showAllCarReservations ? (
        <CurrentReservationsAdmin
          token={token}
          setShowAllCarReservations={setShowAllCarReservations}
        />
      ) : (
        <div className="menu-group">
          {/* Show UploadLicense for Drivers who haven't uploaded it */}
          {role === 'Driver' && !licenseUploaded && (
            <UploadLicense token={token} />
          )}
          {/* Show the active reservation, if it exists */}
          {userReservation ? (
            <ViewReservation token={token} reservationData={userReservation} />
          ) : (<></>)}
          <div className="button-group">
            <button
              onClick={() => setShowProfile(true)}
              className="goto-register-button"
            >
              View Profile
            </button>
            <button
              onClick={() => setShowReserve(true)}
              className="goto-register-button"
            >
              {role === 'Driver' ? 'Reserve Vehicle' : 'View Vehicles'}
            </button>
            {/* Admin and Manager options */}
            {(role === 'Admin' || role === 'Manager') && (
              <button
                onClick={() => setShowAllCarReservations(true)}
                className="goto-register-button"
              >
                View All Reservations
              </button>
            )}
            <button
              onClick={() => {
                // Log out user
                setToken(null);
                setRole('');
                setShowProfile(false);
                setShowReserve(false);
                setShowAddVehicle(false);
                setShowAllCarReservations(false);
              }}
              className="goto-register-button"
            >
              Log Out
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\AddVehicle.js
--- CONTENT START ---
import React, { useState } from 'react';
import '../CSS/Profile.css';
import '../CSS/AddVehicle.css';
import { createVehicle } from '../services/vehicleService';

function AddVehicle({ token, setShowAddVehicle }) {
  const [vehicleName, setVehicleName] = useState('');
  const [hp, setHp] = useState('');
  const [engine, setEngine] = useState('');
  const [color, setColor] = useState('');
  const [year, setYear] = useState('');
  const [msg, setMsg] = useState('');

  const handleAddVehicle = async (e) => {
    e.preventDefault();
    const vehicle = { vehicleName, engine, hp, color, year };
    const result = await createVehicle(vehicle, token);
    if (result.success) {
      setShowAddVehicle(false);
    } else {
      setMsg(result.error || 'Failed to add vehicle');
    }
  };

  return (
    <div className="add-vehicle-container">
      <h2>Add vehicle</h2>
      <form onSubmit={handleAddVehicle}>
        <input placeholder="Vehicle Name" value={vehicleName} onChange={(e)=>setVehicleName(e.target.value)} className="add-vehicle-input" />
        <input placeholder="Vehicle Color" value={color} onChange={(e)=>setColor(e.target.value)} className="add-vehicle-input" />
        <input placeholder="Vehicle Year" value={year} onChange={(e)=>setYear(e.target.value)} className="add-vehicle-input" />
        <input placeholder="Engine" value={engine} onChange={(e)=>setEngine(e.target.value)} className="add-vehicle-input" />
        <input placeholder="HP" value={hp} onChange={(e)=>setHp(e.target.value)} className="add-vehicle-input" />
        <button type="submit" className="add-vehicle-button">Add vehicle</button>
      </form>
      <button onClick={() => setShowAddVehicle(false)} className="goto-vehicle-select-button">Back to Vehicle selection</button>
      {msg && <p className="error-message">{msg}</p>}
    </div>
  );
}
export default AddVehicle;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\CurrentReservationsAdmin.js
--- CONTENT START ---
import React, { useState, useEffect } from 'react';
import '../CSS/Reservations.css';
import { getAdminReservations } from '../services/vehicleService';

function CurrentReservationsAdmin({ token, setShowAllCarReservations }) {
  const [reservations, setReservations] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchReservations = async () => {
      try {
        console.log('[CurrentReservationsAdmin] Fetching reservations...');
        const result = await getAdminReservations(token);

        console.log('[CurrentReservationsAdmin] Raw API Response:', result);

        if (result?.success && Array.isArray(result.data?.data)) {
          console.log('[CurrentReservationsAdmin] Reservations fetched:', result.data.data);
          setReservations(result.data.data);
        } else {
          console.error('[CurrentReservationsAdmin] Invalid data format:', result);
          throw new Error('Invalid data format in response.');
        }
      } catch (err) {
        console.error('[CurrentReservationsAdmin] Error:', err.message);
        setError('Failed to fetch reservations.');
      } finally {
        setLoading(false);
      }
    };

    fetchReservations();
  }, [token]);

  if (loading) {
    return <p>Loading reservations...</p>;
  }

  if (error) {
    return <p className="error-message">Error: {error}</p>;
  }

  if (!reservations.length) {
    return (
      <div className="reservations-container">
        <h2>Current Car Reservations</h2>
        <p>No reservations found.</p>
        <button
          onClick={() => setShowAllCarReservations(false)}
          className="goto-register-button"
        >
          Back to Dashboard
        </button>
      </div>
    );
  }

  return (
    <div className="reservations-container">
      <h2>Current Car Reservations</h2>
      <table className="reservations-table">
        <thead>
          <tr>
            <th>Reservation ID</th>
            <th>Vehicle Name</th>
            <th>Color</th>
            <th>Engine</th>
            <th>Start Date</th>
            <th>End Date</th>
            <th>User Email</th>
            <th>License Image</th>
          </tr>
        </thead>
        <tbody>
          {reservations.map((reservation) => {
            const vehicle = reservation.vehicle || {};
            const user = reservation.user || {};

            return (
              <tr key={reservation.reservationId || Math.random()}>
                <td>{reservation.reservationId || 'N/A'}</td>
                <td>{vehicle.vehicleName || 'N/A'}</td>
                <td>{vehicle.color || 'N/A'}</td>
                <td>{vehicle.engine || 'N/A'}</td>
                <td>{reservation.startDate || 'N/A'}</td>
                <td>{reservation.endDate || 'N/A'}</td>
                <td>{user.email || 'N/A'}</td>
                <td>
                  {user.licenseImageUrl ? (
                    <img
                      src={user.licenseImageUrl}
                      alt="License"
                      className="license-thumbnail"
                    />
                  ) : (
                    'N/A'
                  )}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
      <button
        onClick={() => setShowAllCarReservations(false)}
        className="goto-register-button"
      >
        Back to Dashboard
      </button>
    </div>
  );
}

export default CurrentReservationsAdmin;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\Login.js
--- CONTENT START ---
// components/Login.js
import React, { useState } from 'react';
import '../CSS/LoginRegister.css';
import { auth, signInWithEmailAndPassword } from '../firebaseClient';

function Login({ setToken }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      // Log in using Firebase Authentication
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;

      // Fetch the token and role
      const token = await user.getIdTokenResult();
      const role = token.claims.role || 'Driver'; // Default to Driver if no role
      
      localStorage.setItem('userRole', role); // Save role locally for role-based UI
      setToken(token.token); // Set token to be used in the app
      setError('');
    } catch (error) {
      setError(error.message); // Display error message if login fails
    }
  };

  return (
    <div className="login-container">
      <h2>Login</h2>
      <form onSubmit={handleLogin}>
        <input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="login-input"
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="login-input"
        />
        <button type="submit" className="login-button">Login</button>
      </form>
      {error && <p className="error-message">{error}</p>}
    </div>
  );
}

export default Login;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\MalfunctionMessage.js
--- CONTENT START ---
import React, { useState, useEffect } from "react";
import { getMalfunctionData } from "../services/vehicleService";

const MalfunctionMessage = ({ vehicleId, setShowMessage, token }) => {
  const [message, setMessage] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchMessage = async () => {
      setLoading(true);
      try {
        const result = await getMalfunctionData(token);
        if (result.success) {
          const malfunction = result.data.find((m) => m.vehicleId === vehicleId);
          setMessage(malfunction ? malfunction.description : "No message found.");
        } else {
          setError(result.error || "Failed to fetch malfunction message.");
        }
      } catch (error) {
        setError(error.message);
      } finally {
        setLoading(false);
      }
    };
    fetchMessage();
  }, [vehicleId, token]);

  return (
    <div className="malfunction-message">
      <h2>Malfunction Message</h2>
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p>Error loading message: {error}</p>
      ) : (
        <p>{message}</p>
      )}
      <button onClick={() => setShowMessage(null)} className="back-button">
        Back
      </button>
    </div>
  );
};

export default MalfunctionMessage;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\Profile.js
--- CONTENT START ---
// components/Profile.js
import React, { useState, useEffect, useCallback } from 'react';
import '../CSS/Profile.css';
import { getUserData, uploadLicense } from '../services/authService';

function Profile({ token, setShowProfile }) {
  const [email, setEmail] = useState('');
  const [role, setRole] = useState('');
  const [licenseImageUrl, setLicenseImageUrl] = useState(null);
  const [message, setMessage] = useState('');
  const [file, setFile] = useState(null);

  // Function to fetch and update user data
  const fetchUserData = useCallback(async () => {
    const result = await getUserData(token);
    if (result.success) {
      setEmail(result.data.email);
      setRole(result.data.role || 'Driver'); // Default role to Driver
      setLicenseImageUrl(result.data.licenseImageUrl);
    } else {
      setMessage(result.error || 'Failed to load profile data');
    }
  }, [token]);

  // Initial data fetch
  useEffect(() => {
    fetchUserData();
  }, [token, fetchUserData]);

  const handleFileChange = (e) => {
    setFile(e.target.files[0]);
  };

  const handleUpload = async (e) => {
    e.preventDefault();
    if (file) {
      const result = await uploadLicense(file, token);
      if (result.success) {
        setMessage('License uploaded successfully');
        fetchUserData(); // Fetch the updated user data immediately after upload
      } else {
        setMessage(result.error || 'Failed to upload license');
      }
    } else {
      setMessage('Please select a file to upload');
    }
  };

  return (
    <div className="profile-container">
      <h2>Profile</h2>
      <p className="profile-email">Email: {email}</p>
      <p className="profile-role">Role: {role}</p>
      {licenseImageUrl ? (
        <div>
          <h3>Your Driver’s License</h3>
          <img src={licenseImageUrl} alt="Driver's License" className="license-image" />
        </div>
      ) : (
        <p className="no-license">No driver's license uploaded yet.</p>
      )}
      <div>
        <h3>Update Driver’s License</h3>
        <form onSubmit={handleUpload}>
          <input type="file" onChange={handleFileChange} />
          <button type="submit" className="upload-button">
            Upload License
          </button>
        </form>
      </div>
      <button onClick={() => setShowProfile(false)} className="goto-register-button">
        Back to Dashboard
      </button>
      {message && <p className="profile-message">{message}</p>}
    </div>
  );
}

export default Profile;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\Register.js
--- CONTENT START ---
import React, { useState } from 'react';
import '../CSS/LoginRegister.css';
import { auth, db } from '../firebaseClient';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { doc, setDoc } from 'firebase/firestore';
import UploadLicense from './UploadLicense';

function Register({ setToken }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [showUploadLicense, setShowUploadLicense] = useState(false);
  const [uploadToken, setUploadToken] = useState(null); // <-- keep token for UploadLicense

  const handleRegister = async (e) => {
    e.preventDefault();
    try {
      // Create the user
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;

      // Get a fresh ID token once
      const idToken = await user.getIdToken();
      setToken(idToken);
      setUploadToken(idToken);

      // Add user data to Firestore
      await setDoc(doc(db, 'users', user.uid), {
        email: user.email,
        role: 'Driver',
        createdAt: new Date().toISOString(),
      });

      // Show Upload License step
      setShowUploadLicense(true);
      setError('');
    } catch (err) {
      console.error('Error during registration:', err);
      setError(err.message);
    }
  };

  if (showUploadLicense) {
    return <UploadLicense token={uploadToken || ''} />;
  }

  return (
    <div className="login-container">
      <h2>Register</h2>
      <form onSubmit={handleRegister}>
        <input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="login-input"
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="login-input"
        />
        <button type="submit" className="login-button">
          Register
        </button>
      </form>
      {error && <p className="error-message">{error}</p>}
    </div>
  );
}

export default Register;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\ReportIssueForm.js
--- CONTENT START ---
// components/ReportIssueForm.js
import React, { useState } from "react";
import { reportVehicleIssue } from "../services/vehicleService"; // Import the service function
import { getAuth } from "firebase/auth"; // Import Firebase Authentication

function ReportIssueForm({ vehicleId, setShowReportIssue, fetchVehicles }) {
  const [issueDescription, setIssueDescription] = useState("");
  const [message, setMessage] = useState("");

  const handleReportIssueSubmit = async (e) => {
    e.preventDefault();
    if (!issueDescription) {
      setMessage("Please describe the issue before submitting.");
      return;
    }

    try {
      // Fetch the Firebase token
      const auth = getAuth();
      const token = await auth.currentUser.getIdToken();

      console.log("Fetched Firebase token:", token); // Debugging log

      // Call the service to report the issue
      const result = await reportVehicleIssue(vehicleId, { description: issueDescription }, token);
      if (result.success) {
        setMessage("Issue reported successfully.");
        fetchVehicles(); // Refresh the vehicle data
        setShowReportIssue(null); // Close the form
      } else {
        setMessage(result.error);
      }
    } catch (error) {
      console.error("Error reporting issue:", error);
      setMessage("Failed to report the issue. Please try again.");
    }
  };

  return (
    <div className="report-issue-form">
      <h2>Report Issue</h2>
      <form onSubmit={handleReportIssueSubmit}>
        <textarea
          value={issueDescription}
          onChange={(e) => setIssueDescription(e.target.value)}
          placeholder="Describe the issue"
        />
        <button type="submit">Submit</button>
      </form>
      {message && <p className="error-message">{message}</p>}
    </div>
  );
}

export default ReportIssueForm;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\ReservationControls.js
--- CONTENT START ---
import React from "react";

const ReservationControls = ({ canAddVehicle, canViewAllReservations, setShowReserve, setShowAddVehicle, setShowAllCarReservations, userReservationReset }) => {
  return (
    <div className="button-group">
      <button
        onClick={() => {
          setShowReserve(false);
          userReservationReset(null);
        }}
        className="back-button"
      >
        Back to Dashboard
      </button>
      {canAddVehicle && (
        <button onClick={() => setShowAddVehicle(true)} className="back-button">
          Add Vehicle
        </button>
      )}
      {canViewAllReservations && (
        <button
          onClick={() => setShowAllCarReservations(true)}
          className="back-button"
        >
          View All Reservations
        </button>
      )}
    </div>
  );
};

export default ReservationControls;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\ReserveVehicle.js
--- CONTENT START ---
import React, { useState, useEffect, useCallback } from "react";
import { getUserData } from "../services/authService";
import {
  getVehicleData,
  deleteVehicle,
  repairVehicle,
  unreserveVehicle,
} from "../services/vehicleService";
import {
  getReservationData,
  deleteReservation,
} from "../services/reservationService";
import ReserveVehicleForm from "./ReserveVehicleForm";
import ReportIssueForm from "./ReportIssueForm";
import VehicleTable from "./VehicleTable";
import VehicleDetail from "./VehicleDetail";
import MalfunctionMessage from "./MalfunctionMessage";
import ReservationControls from "./ReservationControls";
import { getAuth } from "firebase/auth";

function Reserve({
  token,
  setShowReserve,
  setShowAddVehicle,
  setShowAllCarReservations,
  userReservationReset,
}) {
  const [message, setMessage] = useState("");
  const [vehicles, setVehicles] = useState([]);
  const [reservations, setReservations] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [viewVehicle, setViewVehicle] = useState(null);
  const [reserveVehicleId, setReserveVehicleId] = useState(null);
  const [role, setRole] = useState("");
  const [uid, setUid] = useState(null);
  const [userReservation, setUserReservation] = useState(null);
  const [reportIssueVehicleId, setReportIssueVehicleId] = useState(null);
  const [showMessage, setShowMessage] = useState(null);

  const canAddVehicle = role === "Admin";
  const canRepairVehicle = role === "Admin";
  const canDeleteVehicle = role === "Admin";
  const canViewAllReservations = role === "Admin" || role === "Manager";

  // Debugging: Log variables after all dependencies are declared
  useEffect(() => {
    console.log("Reserve Debug - Vehicles:", vehicles);
    console.log("Reserve Debug - Can Repair Vehicle:", canRepairVehicle);
    console.log(
      "Reserve Debug - Handle View Message Function:",
      handleViewMessage
    );
  }, [vehicles, canRepairVehicle]);

  const fetchVehicles = useCallback(async () => {
    setLoading(true);
    try {
      const vehicleSnapshot = await getVehicleData(token);
      const reservationSnapshot = await getReservationData(token);

      if (vehicleSnapshot.success) {
        setVehicles(vehicleSnapshot.data);
      } else {
        setMessage(vehicleSnapshot.error || "Failed to load vehicle data");
      }

      if (reservationSnapshot.success) {
        setReservations(reservationSnapshot.data);
      } else {
        setMessage(reservationSnapshot.error || "Failed to load reservations.");
      }
    } catch (error) {
      console.error("Error fetching data:", error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  }, [token]);

useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    const userData = await getUserData(token);
    if (userData.success) {
      setRole(userData.data.role || "Driver");
      const auth = getAuth();
      const user = auth.currentUser;
      user ? setUid(user.uid) : setUid(null);
      await fetchVehicles();
    } else {
      // IMPORTANT: clear loading and show a helpful message
      setMessage(userData.error || "Failed to load profile");
      setLoading(false);
    }
  };
  fetchData();
}, [token, fetchVehicles]);

  useEffect(() => {
    if (reservations.length > 0 && uid) {
      const userRes = reservations.find((res) => res.userId === uid);
      setUserReservation(userRes);
    }
  }, [reservations, uid]);

  const handleReserve = (vehicleId) => {
    setReserveVehicleId(vehicleId);
  };

  const removeReserve = async (vehicle) => {
    try {
      const result = await unreserveVehicle(vehicle.vehicleId, token);
      if (result.success) {
        const reservation = reservations.find(
          (res) => res.vehicleId === vehicle.vehicleId && res.userId === uid
        );
        if (reservation) {
          const deleteResult = await deleteReservation(
            reservation.reservationId,
            token
          );
          if (deleteResult.success) {
            setUserReservation(null);
            await fetchVehicles();
          } else {
            console.error("Failed to delete reservation:", deleteResult.error);
          }
        }
      } else {
        console.error("Failed to unreserve vehicle:", result.error);
      }
    } catch (error) {
      console.error("Error removing reservation:", error);
    }
  };

  const handleView = (vehicle) => {
    setViewVehicle(vehicle);
  };

  const handleRepair = async (vehicleId) => {
    const result = await repairVehicle(vehicleId, token);
    if (result.success) {
      await fetchVehicles();
    }
  };

  const handleDelete = async (vehicleId) => {
    const result = await deleteVehicle(vehicleId, token);
    if (result.success) {
      await fetchVehicles();
    }
  };

  const handleViewMessage = (vehicleId) => {
    setShowMessage(vehicleId);
  };

  const sanitizeMessage = (msg) => {
    if (msg && msg.startsWith("Unexpected token '<'")) {
      return ""; // Return an empty string or a default message to hide it
    }
    return msg; // Otherwise, keep the original message
  };

  if (reserveVehicleId) {
    return (
      <ReserveVehicleForm
        token={token}
        reserveVehicleId={reserveVehicleId}
        setReserveVehicleId={setReserveVehicleId}
        fetchVehicles={fetchVehicles}
      />
    );
  }

  if (viewVehicle) {
    return (
      <VehicleDetail
        viewVehicle={viewVehicle}
        setViewVehicle={setViewVehicle}
        userReservationReset={userReservationReset}
      />
    );
  }

  if (reportIssueVehicleId) {
    return (
      <ReportIssueForm
        vehicleId={reportIssueVehicleId}
        setShowReportIssue={() => setReportIssueVehicleId(null)}
        fetchVehicles={fetchVehicles}
      />
    );
  }

  if (showMessage) {
    return (
      <MalfunctionMessage
        vehicleId={showMessage}
        setShowMessage={setShowMessage}
        token={token} // Pass token for API calls
      />
    );
  }

  return (
    <div className="vehicle-container">
      <h2>List of All Vehicles</h2>
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p>Error loading vehicles: {error}</p>
      ) : vehicles.length === 0 ? (
        <p>No vehicles found.</p>
      ) : (
        <VehicleTable
          vehicles={vehicles}
          userReservation={userReservation}
          canRepairVehicle={canRepairVehicle}
          canDeleteVehicle={canDeleteVehicle}
          handleView={handleView}
          handleReserve={handleReserve}
          removeReserve={removeReserve}
          setReportIssueVehicleId={setReportIssueVehicleId}
          handleRepair={handleRepair}
          handleDelete={handleDelete}
          handleViewMessage={handleViewMessage}
        />
      )}
      <ReservationControls
        canAddVehicle={canAddVehicle}
        canViewAllReservations={canViewAllReservations}
        setShowReserve={setShowReserve}
        setShowAddVehicle={setShowAddVehicle}
        setShowAllCarReservations={setShowAllCarReservations}
        userReservationReset={userReservationReset}
      />
      {message && <p className="profile-message">{sanitizeMessage(message)}</p>}
    </div>
  );
}

export default Reserve;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\ReserveVehicleForm.js
--- CONTENT START ---
// ReserveVehicleForm.js

import React, { useState } from 'react';
import Calendar from 'react-calendar';
import 'react-calendar/dist/Calendar.css';
import '../App.css';
import '../CSS/Profile.css';
import '../CSS/ReserveVehicle.css';
import '../CSS/AddVehicle.css';
import { reserveVehicle } from '../services/vehicleService';
import { db, collection, doc } from '../firebaseClient'; // Import Firestore
import { getAuth } from 'firebase/auth'; // Import Firebase Authentication

function ReserveVehicleForm({ token, reserveVehicleId, setReserveVehicleId, fetchVehicles }) {
  const [endDate, setEndDate] = useState(new Date());
  const startDate = new Date().toISOString().split('T')[0]; // Current date in 'YYYY-MM-DD' format
  const status = 'Active';
  const [message, setMessage] = useState('');

  const handleReservationSubmit = async (e) => {
    e.preventDefault();

    console.log('[ReserveVehicleForm] Start Date:', startDate);
    console.log('[ReserveVehicleForm] End Date:', endDate);

    // Get the authenticated user's UID
    const auth = getAuth();
    const user = auth.currentUser;
    const uid = user ? user.uid : null;

    if (!uid) {
      console.error('[ReserveVehicleForm] User not authenticated.');
      setMessage('Please log in to make a reservation.');
      return;
    }

    if (!endDate) {
      console.error('[ReserveVehicleForm] End date is missing.');
      setMessage('Please select an end date.');
      return;
    }

    // Generate a unique document reference with a new ID
    const reservationRef = doc(collection(db, 'reservation'));
    const reservationId = reservationRef.id;

    const newReservation = {
      reservationId,
      vehicleId: reserveVehicleId,
      userId: uid, // Use the authenticated user's UID
      startDate: startDate,
      endDate: endDate.toISOString().split('T')[0],
      status: status,
    };

    console.log('[ReserveVehicleForm] New reservation data:', newReservation);

    try {
      // Add the document with the custom ID and data
      //await setDoc(reservationRef, newReservation);
      console.log(`[ReserveVehicleForm] Added reservation with ID: ${reservationId}`);
      setReserveVehicleId(null);

      // Call backend to update vehicle status
      const result = await reserveVehicle(reserveVehicleId, {
        startDate,
        endDate: endDate.toISOString().split('T')[0],
      }, token);

      console.log('[ReserveVehicleForm] Reserve vehicle response:', result);

      if (result.success) {
        console.log(`[ReserveVehicleForm] Vehicle ${reserveVehicleId} status updated.`);
        fetchVehicles(); // Refresh the list of vehicles
      } else {
        console.error(`[ReserveVehicleForm] Failed to update vehicle status for ID: ${reserveVehicleId}`);
        setMessage('Failed to reserve vehicle. Please try again.');
      }
    } catch (error) {
      console.error('[ReserveVehicleForm] Error adding reservation:', error);
      setMessage('An error occurred while reserving the vehicle.');
    }
  };

  return (
    <div className="add-vehicle-container">
      <h2>Reserve Vehicle</h2>
      <form onSubmit={handleReservationSubmit}>
        <label>Start Date: {startDate}</label>
        <br />
        <label htmlFor="endDate">Select End Date:</label>
        <Calendar
          onChange={setEndDate}
          value={endDate}
          minDate={new Date()} // Prevent selection of past dates
        />
        <br />
        <button type="submit" className="add-vehicle-button">Reserve</button>
      </form>
      <button onClick={() => setReserveVehicleId(null)} className="goto-vehicle-select-button">
        Back to Vehicle selection
      </button>
      {message && <p className="profile-message">{message}</p>}
    </div>
  );
}

export default ReserveVehicleForm;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\UploadLicense.js
--- CONTENT START ---
// components/UploadLicense.js
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import '../CSS/UploadLicense.css';
import { uploadLicense } from '../services/authService';

function UploadLicense({ token, setLicenseUploaded }) {
  const [file, setFile] = useState(null);
  const [message, setMessage] = useState('');

  const handleFileChange = (e) => {
    setFile(e.target.files[0]);
  };

  const handleUpload = async (e) => {
    e.preventDefault();
    if (file && token) {
      try {
        const result = await uploadLicense(file, token);
        if (result.success) {
          setMessage(result.message || 'Upload successful');
          if (setLicenseUploaded) {
            setLicenseUploaded(true); // Update state in the parent component
          }
        } else {
          setMessage(result.error || 'Upload failed');
        }
      } catch (err) {
        setMessage('An error occurred while uploading. Please try again.');
        console.error('[UploadLicense] Error:', err);
      }
    } else {
      setMessage('Please select a file and make sure you are logged in.');
    }
  };

  return (
    <div className="upload-container">
      <h2>Upload Driver's License</h2>
      <form onSubmit={handleUpload} className="upload-form">
        <input
          type="file"
          onChange={handleFileChange}
          className="file-input"
          accept="image/*"
        />
        <button type="submit" className="upload-button">
          Upload
        </button>
      </form>
      {message && <p className="upload-message">{message}</p>}
    </div>
  );
}

UploadLicense.propTypes = {
  token: PropTypes.string.isRequired, // Ensure the token is passed as a string
  setLicenseUploaded: PropTypes.func, // This is optional now to avoid breaking the component
};

export default UploadLicense;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\VehicleDetail.js
--- CONTENT START ---
import React from "react";

const VehicleDetail = ({ viewVehicle, setViewVehicle, userReservationReset }) => {
  return (
    <div className="vehicle-detail">
      <h2>{viewVehicle.vehicleName} Details</h2>
      <img src={viewVehicle.image} alt={viewVehicle.vehicleName} />
      <table className="vehicle-table">
        <tbody>
          <tr>
            <td>Vehicle Name:</td>
            <td>{viewVehicle.vehicleName}</td>
          </tr>
          <tr>
            <td>Engine:</td>
            <td>{viewVehicle.engine}</td>
          </tr>
          <tr>
            <td>Horsepower:</td>
            <td>{viewVehicle.hp} HP</td>
          </tr>
          <tr>
            <td>Color:</td>
            <td>{viewVehicle.color}</td>
          </tr>
          <tr>
            <td>Year:</td>
            <td>{viewVehicle.year}</td>
          </tr>
          <tr>
            <td>Status:</td>
            <td>{viewVehicle.status}</td>
          </tr>
        </tbody>
      </table>
      <button
        onClick={() => {
          setViewVehicle(null);
          userReservationReset(null);
        }}
        className="goto-register-button"
      >
        Back to vehicle list
      </button>
    </div>
  );
};

export default VehicleDetail;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\VehicleRow.js
--- CONTENT START ---
import React from "react";

const VehicleRow = ({ vehicle, userReservation, canRepairVehicle, canDeleteVehicle, handleView, handleReserve, removeReserve, setReportIssueVehicleId, handleRepair, handleDelete, handleViewMessage }) => {
  const status = vehicle.status;

  // Debugging
  console.log("VehicleRow Debug - Vehicle:", vehicle);
  console.log("VehicleRow Debug - Status:", status);
  console.log("VehicleRow Debug - Can Repair Vehicle:", canRepairVehicle);

  return (
    <tr className={status}>
      <td>{vehicle.vehicleName}</td>
      <td>
        {vehicle.engine} - {vehicle.hp} HP
      </td>
      <td>
        <div className="vehicle-actions">
          <button onClick={() => handleView(vehicle)} className="view-button">
            View
          </button>
          {status === "available" && !userReservation && (
            <button onClick={() => handleReserve(vehicle.vehicleId)} className="reserve-button">
              Reserve
            </button>
          )}
          {status !== "available" && userReservation?.vehicleId === vehicle.vehicleId && (
            <>
              <button onClick={() => removeReserve(vehicle)} className="reserve-button">
                Remove Reserve
              </button>
              <button onClick={() => setReportIssueVehicleId(vehicle.vehicleId)} className="reserve-button">
                Report Issue
              </button>
            </>
          )}
          {canRepairVehicle && status === "repair" && (
            <>
              <button onClick={() => handleRepair(vehicle.vehicleId)} className="reserve-button">
                Repair
              </button>
              <button onClick={() => handleViewMessage(vehicle.vehicleId)} className="reserve-button">
                View Message
              </button>
            </>
          )}
          {canDeleteVehicle && (
            <button onClick={() => handleDelete(vehicle.vehicleId)} className="reserve-button">
              Delete
            </button>
          )}
        </div>
      </td>
    </tr>
  );
};

export default VehicleRow;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\VehicleTable.js
--- CONTENT START ---
import React from "react";
import VehicleRow from "./VehicleRow";

const VehicleTable = ({ vehicles, userReservation, canRepairVehicle, canDeleteVehicle, handleView, handleReserve, removeReserve, setReportIssueVehicleId, handleRepair, handleDelete, handleViewMessage }) => {
  // Debugging
  console.log("VehicleTable Debug - Vehicles:", vehicles);
  console.log("VehicleTable Debug - Handle View Message Function:", handleViewMessage);

  return (
    <table className="vehicle-table">
      <thead>
        <tr>
          <th>Vehicle Name</th>
          <th>Engine</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        {vehicles.map((vehicle) => (
          <VehicleRow
            key={vehicle.vehicleId}
            vehicle={vehicle}
            userReservation={userReservation}
            canRepairVehicle={canRepairVehicle}
            canDeleteVehicle={canDeleteVehicle}
            handleView={handleView}
            handleReserve={handleReserve}
            removeReserve={removeReserve}
            setReportIssueVehicleId={setReportIssueVehicleId}
            handleRepair={handleRepair}
            handleDelete={handleDelete}
            handleViewMessage={handleViewMessage}
          />
        ))}
      </tbody>
    </table>
  );
};

export default VehicleTable;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\components\ViewReservation.js
--- CONTENT START ---
// components/ViewReservation.js
import React, { useState, useEffect } from 'react';
import '../CSS/UploadLicense.css';
import '../CSS/ReserveVehicle.css';

import { getVehicleData } from '../services/vehicleService';

function ViewRes({token, reservationData}) {
    const [vehicles, setVehicles] = useState([]); 
    const [userVehicle, setUserVehicle] = useState(null); 

    useEffect(() => {
        const fetchVehicles = async () => {
            try {
            const vehicleSnapshot = await getVehicleData(token);
            if (vehicleSnapshot.success) {
                setVehicles(vehicleSnapshot.data);
            } 
            } catch (error) {
            console.log(error);
            }
        };
        fetchVehicles();
    }, [token]);

    useEffect(() => {
        // Fetch user reservation only after `reservations` and `uid` have been set
        if (vehicles.length > 0) {
          const userRes = vehicles.find(res => res.vehicleId === reservationData.vehicleId);
          setUserVehicle(userRes);
        }
      }, [vehicles, reservationData.vehicleId]); // Add reservationData.vehicleId here

    

    if(userVehicle) return(
      <div className="reservation-container">
        <h2>Your Current Reservation</h2>
            <table className="vehicle-table">
                <tbody>
                <tr>
                    <td><strong>Vehicle Name:</strong></td>
                    <td>{userVehicle.vehicleName}</td>
                </tr>
                <tr>
                    <td><strong>Start Date:</strong></td>
                    <td>{reservationData.startDate}</td>
                </tr>
                <tr>
                    <td><strong>End Date:</strong></td>
                    <td>{reservationData.endDate}</td>
                </tr>
                <tr>
                    <td><strong>Status:</strong></td>
                    <td>{reservationData.status}</td>
                </tr>
                </tbody>
            </table>
      </div>
    )

    return(<></>);
}

export default ViewRes;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\config.js
--- CONTENT START ---
// frontend/src/config.js
const ENV_URL = process.env.REACT_APP_API_URL;

const config = {
  getApiUrl: async () => {
    if (ENV_URL) return ENV_URL; // ✅ explicit at build time

    // Fallbacks, only used in dev if you forget to set the env var:
    const host = typeof window !== 'undefined' ? window.location.hostname : '';
    const onFirebase =
      host.endsWith('.web.app') || host.endsWith('.firebaseapp.com');

    if (onFirebase) {
      return 'https://vehicle-management-frontend-alpha.vercel.app/api';
    }
    return 'http://localhost:3000/api';
  },
};

export default config;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\firebaseClient.js
--- CONTENT START ---
// src/firebaseClient.js
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword } from 'firebase/auth';
import { getFirestore, collection, addDoc, doc, setDoc} from 'firebase/firestore'; // Import Firestore
import firebaseConfig from './firebaseConfig';

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app); // Initialize Firestore

export { auth, db, signInWithEmailAndPassword, createUserWithEmailAndPassword ,collection, addDoc, doc, setDoc};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\firebaseConfig.js
--- CONTENT START ---
const firebaseConfig = {
    apiKey: "AIzaSyCkN8jy9U1CyiZFfvfS9msRIMomQgrME9k",
    authDomain: "company-vehicle-management.firebaseapp.com",
    projectId: "company-vehicle-management",
    storageBucket: "company-vehicle-management.firebasestorage.app",
    messagingSenderId: "246118144076",
    appId: "1:246118144076:web:72c6742bf25f6573bbbce9"
  };

export default firebaseConfig;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\index.css
--- CONTENT START ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\index.js
--- CONTENT START ---
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const container = document.getElementById('root');
createRoot(container).render(<App />);
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\reportWebVitals.js
--- CONTENT START ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\services\authService.js
--- CONTENT START ---
import config from '../config';

export const uploadLicense = async (file, token) => {
  const formData = new FormData();
  formData.append('licenseImage', file);

  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/auth/upload-license`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
      },
      body: formData,
    });
    const data = await response.json();
    if (response.ok) {
      return { success: true, message: data.message };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const getUserData = async (token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/auth/profile`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    const ct = response.headers.get('content-type') || '';
    if (!ct.includes('application/json')) {
      const text = await response.text();
      // Make the error explicit instead of throwing JSON parse errors
      return { success: false, error: `Non-JSON from API (${response.status}). ${text.slice(0,100)}…` };
    }

    const data = await response.json();
    if (response.ok) return { success: true, data };
    return { success: false, error: data.message };
  } catch (error) {
    return { success: false, error: error.message };
  }
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\services\reservationService.js
--- CONTENT START ---
// services/resrvationService.js
import config from '../config';

export const getReservationData = async (token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/reservation/reservation`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const getReservation = async (resId, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/reservation/reservation/${resId}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const deleteReservation = async (resId, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/reservation/reservation/${resId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\services\vehicleService.js
--- CONTENT START ---
// services/vehicleService.js
import config from '../config';

export const createVehicle = async (vehicle, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const res = await fetch(`${API_URL}/vehicle/vehicles`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
      body: JSON.stringify(vehicle),
    });
    const data = await res.json();
    if (res.ok) return { success: true, data };
    return { success: false, error: data.message };
  } catch (e) {
    return { success: false, error: e.message };
  }
};

export const getVehicleData = async (token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      const errorText = await response.text();
      throw new Error(`Unexpected response: ${errorText}`);
    }

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const deleteVehicle = async (vehicleId, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles/${vehicleId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const repairVehicle = async (vehicleId, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles/${vehicleId}/repair`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const unreserveVehicle = async (vehicleId, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles/${vehicleId}/unreserve`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const reserveVehicle = async (vehicleId, reservationData, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles/${vehicleId}/reserve`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(reservationData),
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const getAdminReservations = async (token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/admin-reservations`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const reportVehicleIssue = async (vehicleId, issueData, token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/vehicles/${vehicleId}/report-issue`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(issueData),
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const getMalfunctionData = async (token) => {
  try {
    const API_URL = await config.getApiUrl();
    const response = await fetch(`${API_URL}/vehicle/malfunctions`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (response.ok) {
      return { success: true, data };
    } else {
      return { success: false, error: data.message };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
};

--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\setupTests.js
--- CONTENT START ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\__tests__\CurrentReservationsAdmin.test.js
--- CONTENT START ---
import React from 'react';
import { render, screen } from '@testing-library/react';
import CurrentReservationsAdmin from '../components/CurrentReservationsAdmin';

jest.mock('../services/vehicleService', () => ({
  getAdminReservations: jest.fn(async () => ({
    success: true,
    data: {
      success: true,
      data: [
        {
          reservationId: 'r1',
          startDate: '2025-01-01',
          endDate: '2025-01-02',
          status: 'Active',
          user: { email: 'driver@example.com', licenseImageUrl: null },
          vehicle: { vehicleName: 'Car A', color: 'Red', engine: 'V6' }
        }
      ]
    }
  }))
}));

test('Admin reservations table renders a row', async () => {
  render(<CurrentReservationsAdmin token="tok" setShowAllCarReservations={() => {}} />);
  expect(await screen.findByText(/current car reservations/i)).toBeInTheDocument();
  expect(await screen.findByText('Car A')).toBeInTheDocument();
  expect(screen.getByText('driver@example.com')).toBeInTheDocument();
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\__tests__\Login.test.js
--- CONTENT START ---
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Login from '../components/Login';

// Mock firebaseClient exports used by Login
jest.mock('../firebaseClient', () => ({
  auth: {},
  signInWithEmailAndPassword: jest.fn(async () => ({
    user: {
      getIdTokenResult: async () => ({ token: 't123', claims: { role: 'Driver' } })
    }
  }))
}));

test('Login submits and sets token on success', async () => {
  const setToken = jest.fn();
  render(<Login setToken={setToken} />);

  await userEvent.type(screen.getByPlaceholderText(/email/i), 'test@example.com');
  await userEvent.type(screen.getByPlaceholderText(/password/i), 'pass123');
  await userEvent.click(screen.getByRole('button', { name: /login/i }));

  expect(await screen.findByRole('button', { name: /login/i })).toBeInTheDocument();
  expect(setToken).toHaveBeenCalledWith('t123');
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\__tests__\ReserveVehicleForm.test.js
--- CONTENT START ---
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ReserveVehicleForm from '../components/ReserveVehicleForm';

jest.mock('../services/vehicleService', () => ({
  reserveVehicle: jest.fn(async () => ({ success: true, data: {} }))
}));

// Mock firebase/auth getAuth -> currentUser.uid
jest.mock('firebase/auth', () => ({
  getAuth: () => ({ currentUser: { uid: 'u1' } })
}));

test('ReserveVehicleForm submits and calls fetchVehicles', async () => {
  const fetchVehicles = jest.fn();
  render(
    <ReserveVehicleForm
      token="tok"
      reserveVehicleId="veh1"
      setReserveVehicleId={() => {}}
      fetchVehicles={fetchVehicles}
    />
  );

  // Just click submit; default endDate is set
  await userEvent.click(screen.getByRole('button', { name: /reserve/i }));
  // allow async
  await new Promise(r => setTimeout(r, 0));
  expect(fetchVehicles).toHaveBeenCalled();
});
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: frontend\src\__tests__\UploadLicense.test.js
--- CONTENT START ---
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import UploadLicense from '../components/UploadLicense';

jest.mock('../services/authService', () => ({
  uploadLicense: jest.fn(async () => ({ success: true, message: 'License image uploaded successfully' }))
}));

test('UploadLicense calls service and shows success', async () => {
  render(<UploadLicense token="tok" />);

  const file = new File(['dummy'], 'license.png', { type: 'image/png' });
  const input = screen.getByLabelText(/upload driver's license/i) || screen.getByRole('textbox', { hidden: true }) || screen.getByRole('button', { name: /upload/i });

  // safer: query by input type=file
  const fileInput = screen.getByLabelText(/upload/i) || document.querySelector('input[type="file"]');
  await userEvent.upload(fileInput, file);

  await userEvent.click(screen.getByRole('button', { name: /upload/i }));
  await waitFor(() => expect(screen.getByText(/uploaded successfully/i)).toBeTruthy());
});
--- CONTENT END ---
=== FILE END ===

====================
OPTIONAL ROOT FILES
====================

=== FILE START ===
Path: .firebaserc
--- CONTENT START ---
{
  "projects": {
    "default": "company-vehicle-management"
  }
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: firebase.json
--- CONTENT START ---
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": {
    "public": "frontend/build",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: firestore.rules
--- CONTENT START ---
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    match /users/{uid} {
      allow create: if signedIn() && request.auth.uid == uid;
      allow read, update: if signedIn() && request.auth.uid == uid;
    }

    // Everything else is server-managed via Admin SDK
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: firestore.indexes.json
--- CONTENT START ---
{
  "indexes": [],
  "fieldOverrides": []
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: package.json
--- CONTENT START ---
{
  "name": "vehicle-management",
  "private": true,
  "engines": { "node": ">=18" },
  "workspaces": ["frontend"],
  "dependencies": {
    "cloudinary": "^2.5.1",
    "firebase-admin": "^12.7.0",
    "formidable": "^3.5.0"
  },
    "scripts": {
    "test": "jest",
    "test:api": "jest",
    "test:frontend": "npm --prefix frontend test -- --watchAll=false"
  },
    "devDependencies": {
    "jest": "^29.7.0",
    "node-mocks-http": "^1.11.0"
  }
}
--- CONTENT END ---
=== FILE END ===

=== FILE START ===
Path: vercel.json
--- CONTENT START ---
{
  "version": 2
}
--- CONTENT END ---
=== FILE END ===
